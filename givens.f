      SUBROUTINE GIVENS (NX,NROOTX,NJX,A,B,ROOT,VECT)
C
C      SUBROUTINE TO CALCULATE THE EIGENVALUES AND EIGENVECTORS
C      OF A REAL SYMMETRIC MATRIX.
C
C
C      THE PARAMETERS FOR THE ROUTINE ARE0
C
C          NX     ORDER OF MATRIX.
C
C          NROOTX NUMBER OF ROOTS FOR WHICH EIGENVECTORS ARE WANTED.
C                 IF NO VECTORS ARE WANTED, MAKE NROOTX NEGATIVE.
C
C          NJX    ROW DIMENSION OF VECT ARRAY.  SEE 'VECT' BELOW.
C                 NJX MUST BE NOT LESS THAN NX.
C
C          A      MATRIX STORED BY COLUMNS IN PACKED UPPER TRIANGULAR
C                 FORM, I.E. OCCUPYING NX*(NX+1)/2 CONSECUTIVE
C                 LOCATIONS.
C
C          B      SCRATCH ARRAY USED BY GIVENS.  MUST BE AT LEAST
C                 NX*6 CELLS.
C
C          ROOT   ARRAY TO HOLD THE EIGENVALUES.  MUST BE AT LEAST
C                 NX CELLS LONG.  THE ROOTS ARE ORDERED LARGEST FIRST
C                 IN THIS ARRAY.
C
C          VECT   EIGENVECTOR ARRAY.  EACH COLUMN WILL HOLD AN
C                 EIGENVECTOR FOR THE CORRESPONDING ROOT.  MUST BE
C                 DIMENSIONED WITH 'NJX' ROWS AND AT LEAST 'NJX'
C                 COLUMNS, UNLESS NO VECTORS ARE REQUESTED (NEGATIVE
C                 NROOTX).  IN THIS LATTER CASE, THE ARGUMENT VECT
C                 IS JUST A DUMMY, AND THE STORAGE IS NOT USED.
C                 THE EIGENVECTORS ARE NORMALIZED TO UNIT LENGTH.
C
C      THE ARRAYS A AND B ARE DESTROYED BY THE COMPUTATION.  THE
C      RESULTS APPEAR IN ROOT AND VECT.
C
C      FOR PROPER FUNCTIONING OF THIS ROUTINE, THE RESULT OF A FLOATING
C      POINT UNDERFLOW SHOULD BE A ZERO.
C
C      THE ORIGINAL REFERENCE TO THE GIVENS TECHNIQUE IS IN OAK RIDGE
C      REPORT NUMBER ORNL 1574 (PHYSICS), BY WALLACE GIVENS.
C
C      THE METHOD AS PRESENTED IN THIS PROGRAM CONSISTS OF FOUR STEPS0
C
C      FIRST, THE INPUT MATRIX IS REDUCED TO TRIDIAGONAL FORM BY THE
C      HOUSEHOLDER TECHNIQUE (J. H. WILKINSON, COMP. J. 3, 23 (1960)).
C      THE EIGENVALUES OF THE TRIDIAGONAL MATRIX ARE THEN FOUND USING
C      THE QR TRANSFORM METHOD.  SEE J. H. WILKINSON, THE ALGEBRAIC
C      EIGENVALUE PROBLEM(1965) FOR A DESCRIPTION OF THIS ALGORITHM.
C      THE EIGENVECTORS OF THE TRIDIAGONAL FORM ARE THEN EVALUATED
C      (J. H. WILKINSON, COMP. J. 1, 90 (1958)), BY THE METHOD OF
C      INVERSE ITERATION, FOR NONDEGENERATE MATRICES.
C      FOR MATRICES WITH DEGENERATE OR NEAR-DEGENERATE EIGENVALUES,
C      THE EIGENVECTORS ARE EVALUATED INSTEAD BY FURTHER QR TRANSFORMS.
C      THIS METHOD GIVES ORTHOGONAL VECTORS EVEN FOR DEGENERATE ROOTS.
C      FINALLY THE TRIDIAGONAL VECTORS ARE ROTATED TO VECTORS OF THE
C      ORIGINAL ARRAY (FIRST REFERENCE).
C
C      THE INVERSE ITERATION PORTION OF THIS PROGRAM WAS ADAPTED
C      FROM THE QUANTUM CHEMISTRY PROGRAM EXCHANGE NUMBER 62.1, BY
C      FRANKLIN PROSSER.  THE EIGENVALUE SUBROUTINE (EVQR) WAS WRITTEN
C      BY WALTER NIELSEN.
C                                      ROY GORDON, SEPT. 1969
C
C      AN EXCELLENT PRESENTATION OF THE GIVENS TECHNIQUE IS FOUND IN
C      J. M. ORTEGA'S ARTICLE IN 'MATHEMATICS FOR DIGITAL COMPUTERS,'
C      VOLUMD 2, ED. BY RALSTON AND WILF, WILEY (1967), PAGE 94.
C
      IMPLICIT Real*8(A-H,R-Z)
      COMMON /VECTOR/ FACT,IDIF
      DIMENSION B(NX,6),A(1),ROOT(NX),VECT(NJX,NROOTX)
C
C  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C  *                                                                 *
C  *   USERS PLEASE NOTE0 TWO PARAMETERS, ETA AND THETA, SHOULD BE   *
C  *   ADJUSTED BY THE USER FOR HIS PARTICULAR MACHINE.              *
C  *                                                                 *
C  *   ETA IS AN INDICATION OF THE PRECISION OF THE FLOATING POINT   *
C  *   REPRESENTATION ON THE COMPUTER BEING USED (ROUGHLY 10**(-M),  *
C  *   WHERE M IS THE NUMBER OF DECIMALS OF PRECISION ).             *
C  *                                                                 *
C  *   THETA IS AN INDICATION OF THE RANGE OF NUMBERS THAT CAN BE    *
C  *   EXPRESSED IN THE FLOATING POINT REPRESENTATION (ROUGHLY THE   *
C  *   LARGEST NUMBER).                                              *
C  *                                                                 *
C  *   SOME RECOMMENDED VALUES FOLLOW.                               *
C  *                                                                 *
C  *   FOR IBM 7094, UNIVAC 1108, ETC. (27-BIT BINARY FRACTION,      *
C  *   8-BIT BINARY EXPONENT), ETA=1.E-8, THETA=1.E37.               *
C  *   FOR CONTROL DATA 3600 (36-BIT BINARY FRACTION, 11-BIT BINARY  *
C  *   EXPONENT), ETA=1.E-11, THETA=1.E307.                          *
C  *   FOR CONTROL DATA 6600 (48-BIT BINARY FRACTION, 11-BIT BINARY  *
C  *   EXPONENT), ETA=1.E-14, THETA=1.E307.                          *
C  *   FOR IBM 360/50 AND 360/65 DOUBLE PRECISION (56-BIT HEXA-      *
C  *   DECIMAL FRACTION, 7-BIT HEXADECIMAL EXPONENT), ETA=1.E-16,    *
C  *   THETA=1.E75.                                                  *
C  *                                                                 *
C  *   OTHER PARAMETERS WHICH MUST BE ADJUSTED ARE0                  *
C  *                                                                 *
C  *   DEL1 = ETA/1.D2, DELTA = ETA**2*1.D2, SMALL = ETA**2/1.D2,    *
C  *   DELBIG = THETA*DELTA/1.D3, THETA1 = 1.D0/THETA, EMAG = ETA,   *
C  *   TOLER = 1.D2*DSQRT(ETA)                                       *
C  *                                                                 *
C  *   TOLER IS A FACTOR USED TO DETERMINE IF ANY ROOTS ARE CLOSE    *
C  *   ENOUGH TOGETHER TO BE CONSIDERED DEGENERATE FOR PURPOSES OF   *
C  *   CALCULATING EIGENVECTORS.  FOR THE MATRIX NORMED TO UNITY, IF *
C  *   THE DIFFERENCE BETWEEN TWO ROOTS IS LESS THAN TOLER, THEN THE *
C  *   QR TRANSFORMATION IS USED TO FORM THE EIGENVECTORS.           *
C  *                                                                 *
C  *   EMAG IS A TOLERANCE FOR NEGLIGIBLE ELEMENTS IN THE QR         *
C  *   ITERATION FOR EIGENVECTORS FOR DEGENERATE EIGENVALUES.        *
C  *                                                                 *
C  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  IN THE FOLLOWING ROUTINE, ETA = 1.D-16 AND THETA = 1.D75.
*     DATA ETA/1.D-16/,THETA/1.D38/,DEL1/1.D-18/,DELTA/1.D-30/,
*    *SMALL/1.D-34/,DELBIG/1.D05/,THETA1/1.D-38/,TOLER/1.D-6/,
*    *EMAG/1.D-16/
C  IN THE FOLLOWING ROUTINE, ETA = 1.D-16 AND THETA = 1.D307.
      DATA ETA/1.D-16/,THETA/1.D307/,DEL1/1.D-18/,DELTA/1.D-30/,
     *SMALL/1.D-34/,DELBIG/1.D274/,THETA1/1.D-307/,TOLER/1.D-6/,
     *EMAG/1.D-16/
C
      N = NX
      FLOATN = DFLOAT(N)
      NROOT = IABS(NROOTX)
      IF (NROOT.EQ.0) GO TO 1001
      IF (N-1) 1001,1003,105
 1003 ROOT(1) = A(1)
      IF (NROOTX.GT.0) VECT(1,1) = 1.D0
      GO TO 1001
  105 CONTINUE
C
C  NSIZE IS THE NUMBER OF ELEMENTS IN THE PACKED ARRAY.
C
      NSIZE = (N*(N+1))/2
      NM1 = N-1
      NM2 = N-2
      NP1 = N+1
C
C  COMPUTE TRACE.
C
      TRACE = 0.D0
      JUMP = 1
      DO 1 J=2,NP1
      TRACE = TRACE + A(JUMP)
    1 JUMP = JUMP + J
      TRACE = TRACE/FLOATN
C
C  SUBTRACT TRACE FROM DIAGONAL ELEMENTS TO GIVE A MORE RELIABLE NORM
C  WHEN THERE ARE LARGE DIAGONAL ELEMENTS.
C
      JUMP = 1
      DO 2 J=2,NP1
      A(JUMP) = A(JUMP) - TRACE
    2 JUMP = JUMP + J
C
C  SCALE MATRIX TO EUCLIDEAN NORM OF 1.  SCALE FACTOR IS ANORM.
C
      FACTOR = 0.D0
      DO 70 I=1,NSIZE
   70 FACTOR = DMAX1(FACTOR,DABS(A(I)))
      IF (FACTOR.NE.0.D0) GO TO 72
C
C  NULL MATRIX.  FIX UP ROOTS AND VECTORS, THEN EXIT.
C
      DO 78 I=1,NROOT
      IF (NROOTX.LT.0) GO TO 78
      DO 77 J=1,N
   77 VECT(J,I) = 0.D0
      VECT(I,I) = 1.D0
   78 ROOT(I) = 0.D0
      GO TO 1001
   72 ANORM = 0.D0
   86 SCALE = 1.D0/FACTOR
      DO 80 I=1,NSIZE
   80 ANORM = ANORM + (A(I)*SCALE)**2
      ANORM = ANORM+ANORM
C
C  SUBTRACT DIAGONAL CONTRIBUTIONS WHICH WERE COUNTED TWICE.
C
      JUMP = 1
      DO 81 J=2,NP1
      ANORM = ANORM -(A(JUMP)*SCALE)**2
   81 JUMP = JUMP + J
   83 ANORM = FACTOR*DSQRT(ANORM)
      SCALE = 1.D0/ANORM
      DO 91 I=1,NSIZE
   91 A(I) = A(I)*SCALE
      ALIMIT = 1.D0
C
C  TRIDIAGONALIZATION OF SYMMETRIC MATRIX.
C
      ID = 0
      IA = 1
      IF (NM2.EQ.0) GO TO 201
      DO 200 J=1,NM2
C
C  J COUNTS ROW OF A MATRIX TO BE DIAGONALIZED. IA INDICATES START OF
C  NON-CODIAGONAL ELEMENTS IN THE ROW. ID IS THE INDEX OF CODIAGONAL
C  ELEMENT ON THE ROW BEING CODIAGONALIZED.
C
      IA = IA+J+2
      ID = ID+J+1
      JP2 = J + 2
      J1 = J + 1
C
C  FIND LIMITS FOR BAND OF SIGNIFICANT MATRIX ELEMENTS.
C
      LIMIT = J1
      II = IA
      DO 99 I=JP2,N
      B(I,5) = A(II)
      IF (DABS(B(I,5)).GT.DEL1) LIMIT = I
   99 II = II + I
      DTEMP = A(ID)
      IF (LIMIT.GT.J1) GO TO 110
C
C  NO TRANSFORMATION NECESSARY IF ALL THE NON-CODIAGONAL
C  ELEMENTS ARE TINY.
C
  120 B(J,1) = DTEMP
      A(ID) = 0.D0
      GO TO 200
C
C  SUM SQUARES OF SIGNIFICANT NON-CODIAGONAL ELEMENTS OF ROW J.
C
  110 IDIF = LIMIT -JP2
      SUM = DOT(B(JP2,5),B(JP2,5))
C
C  NOW COMPLETE THE SUM OF OFF-DIAGONAL SQUARES.
C
      SUM = DSQRT(SUM + DTEMP**2)
C
C  NEW CODIAGONAL ELEMENT.
C
      B(J,1) = -DSIGN(SUM,DTEMP)
C
C  FIRST NON-ZERO ELEMENT OF THIS W-VECTOR.
C
      B(J+1,2) = DSQRT((1.D0 + DABS(DTEMP)/SUM)*5.D-1)
C
C  FORM REST OF THE W-VECTOR ELEMENTS.
C
      TEMP = DSIGN(5.D-1/(B(J+1,2)*SUM),DTEMP)
      II = IA
      DO 130 I=JP2,LIMIT
      B(I,2) = A(II)*TEMP
  130 II = II + I
C
C  FORM P-VECTOR AND SCALAR.  P-VECTOR = A-MATRIX*W-VECTOR.
C  SCALAR = W-VECTOR*P-VECTOR.
C
      DAK = 0.D0
C
C  IC IS THE LOCATION OF THE NEXT DIAGONAL ELEMENT. I RUNS OVER THE
C  NON-ZERO P-ELEMENTS. CASES FOR I LESS THAN LIMIT.
C
      IC = ID + 1
      LIMLES = LIMIT - 1
      DO 188 I=J1,LIMLES
C
C  FORM FIRST PART OF P ELEMENT THEN MOVE IC TO TOP OF NEXT
C  A-MATRIX 'ROW'.
C
      IDIF = I - J1
      DTEMP = DOT(B(J1,2),A(IC))
      IC = IC + I
C
C  COMPLETE P ELEMENT. CHANGE INCREMENTING MODE AT DIAGONAL ELEMENT.
C
  178 IP1 = I + 1
      JJ = IC + IDIF
      DTEMP = DTEMP + DSUM(B(N,1),A(JJ),IP1,LIMIT)
C
C  BUILD UP THE K-SCALAR (AK).
C
      DAK = DAK + DTEMP*B(I,2)
  188 B(I,1) = DTEMP
C
C  CASE FOR I = LIMIT.
C
      IDIF = LIMIT - J1
      DTEMP = DOT(B(J1,2),A(IC))
      DAK = DAK + DTEMP*B(LIMIT,2)
      B(LIMIT,1) = DTEMP
      IDIF = LIMIT - J1
C
C  TEST TO SEE IF ANY I VALUES REMAIN. DO REMAINING VALUES.
C
      IF (LIMIT.EQ.N) GO TO 190
      IC = IC + LIMIT
      LIMLO = LIMIT + 1
      DO 189 I=LIMLO,N
      B(I,1) = DOT(B(J1,2),A(IC))
      B(I,2) = 0.D0
  189 IC = IC + I
C
C  FORM THE Q-VECTOR.
C
  190 FACT = -DAK
      CALL VECSUM(B(J1,1),B(J1,2))
C
C  TRANSFORM THE REST OF THE A-MATRIX. JJ INDICATES START-1 OF THE
C  REST OF THE A-MATRIX. MOVE W-VECTOR INTO THE OLD A-MATRIX LOCATIONS
C  TO SAVE SPACE. I RUNS OVER THE SIGNIFICANT ELEMENTS OF THE W-VECTOR.
C
      JJ = ID
      DO 160 I=J1,N
      A(JJ) = B(I,2)
      IF (I.GT.LIMIT) GO TO 161
      B2 = B(I,2)
      FACT = -B2 - B2
      IDIF = I - J1
      CALL VECSUM(A(JJ+1),B(J1,1))
  161 B1 = B(I,1)
      FACT = -B1 - B1
      IDIF = MIN0(I,LIMIT) - J1
      CALL VECSUM(A(JJ+1),B(J1,2))
  160 JJ = JJ + I
C
C  STORE AWAY LIMIT FOR LATER USE IN BACK TRANSFORMATION. MOVE LAST
C  CODIAGONAL ELEMENT OUT INTO ITS PROPER PLACE.
C
  200 B(J,6) = LIMIT
  201 CONTINUE
      B(NM1,1) = A(NSIZE-1)
      A(NSIZE-1) = 0.D0
C
C  USE QR TRANSFORM METHOD TO FIND EIGENVALUES OF THE TRIDIAGONAL
C  MATRIX. MOVE DIAGONAL ELEMENTS OF THE TRIDIAGONAL MATRIX INTO
C  ROOT ARRAY. THIS IS A MORE CONVENIENT INDEXING POSITION. ALSO,
C  PUT SQUARE OF CODIAGONAL ELEMENTS IN THIRD N ELEMENTS.
C
      JUMP = 0
      DO 320 J=1,NM1
      JUMP = JUMP + J
      ROOT(J) = A(JUMP)
  320 B(J,3) = B(J,1)**2
      ROOT(N) = A(NSIZE)
      CALL EVQR(ROOT,B(1,3),N,30,SMALL)
C
C  ROOT NOW CONTAINS THE SHIFTED AND SCALED EIGENVALUES. STORE
C  EIGENVALUES FOR POSSIBLE LATER USE AS SHIFTS IN EVALUATING
C  EIGENVECTORS FOR DEGENERATE MATRICES.
C
      DO 325 J=1,N
  325 B(J,2) = ROOT(J)
C
C  SORT THE EIGENVALUES INTO DESCENDING ALGEBRAIC ORDER.
C
      DO 330 I=1,NM1
      IP1 = I + 1
      DO 330 J=IP1,N
      IF (ROOT(I).GE.ROOT(J)) GO TO 330
      TEMP = ROOT(I)
      ROOT(I) = ROOT(J)
      ROOT(J) = TEMP
  330 CONTINUE
C
C  QUIT NOW IF NO VECTORS WERE REQUESTED. OTHERWISE, TEST FOR
C  DEGENERACY OR NEAR DEGENERACY OF EIGENVALUES FOR WHICH EIGENVECTORS
C  WERE REQUESTED. IF ONLY ONE VECTOR REQUESTED, DEGENERACY DOESN'T
C  MATTER.
C
      IF (NROOTX.LT.0) GO TO 1002
      IF (NROOTX.EQ.1) GO TO 807
      NTOP = NROOT - 1
      DO 400 I=1,NTOP
      IF (DABS(ROOT(I+1)-ROOT(I)).LE.TOLER) GO TO 410
  400 CONTINUE
C
C  NEXT STATEMENT IS REACHED IF ALL EIGENVALUES FOR WHICH EIGENVECTORS
C  WERE REQUESTED ARE WELL SEPARATED.
C
      GO TO 807
C
C  THE FOLLOWING IS REACHED IF THERE ARE ANY DEGENERATE CLUSTERS
C  OF EIGENVALUES.  USE FURTHER QR TRANSFORMS TO EVALUATE
C  THE EIGENVECTORS OF THE TRIDIAGONAL MATRIX.  THIS METHOD
C  GIVES ORTHOGONAL EIGENVECTORS EVEN WHEN THE EIGENVALUES ARE
C  DEGENERATE.  HOWEVER, IT TAKES MORE ARITHMETIC THAN THE METHOD
C  OF INVERSE ITERATION (AT LEAST AT LARGE N).
C
C  PUT DIAGONAL ELEMENTS OF TRIDIAGONAL MATRIX INTO ROOT.  PUT OFF-
C  DIAGONAL ELEMENTS INTO B(I,3).
C
  410 JUMP = 0
      DO 440 J=1,NM1
      JUMP = JUMP + J
      ROOT(J) = A(JUMP)
  440 B(J,3) = B(J,1)
C
C  LAST DIAGONAL ELEMENT.
C
      ROOT(N) = A(NSIZE)
C
C  INITIALIZE VECTORS TO A UNIT MATRIX.
C
      DO 450 I=1,N
      DO 445 J=1,N
  445 VECT(J,I) = 0.D0
  450 VECT(I,I) = 1.D0
C
C  FORM EIGENVECTORS OF TRIDIAGONAL MATRIX FOR DEGENERATE
C  MATRICES AND TRANSPOSE THE VECTORS.
C
      CALL QRTN(ROOT,B(1,3),VECT,B(1,2),N,25,EMAG,NJX)
      DO 456 I=1,NM1
      IP1 = I + 1
      DO 455 J=IP1,N
      FLIP = VECT(I,J)
      VECT(I,J) = VECT(J,I)
  455 VECT(J,I) = FLIP
  456 CONTINUE
C
C  IF ROOTS WERE NOT LOCATED IN DESCENDING ORDER, INTERCHANGE ROOTS
C  AND VECTORS.
C
      ITOP = NROOT-1
      DO 480 I=1,ITOP
      IP1 = I+1
      DO 480 J=IP1,N
      IF (ROOT(I).GE.ROOT(J)) GO TO 480
      TEMP = ROOT(I)
      ROOT(I) = ROOT(J)
      ROOT(J) = TEMP
      DO 470 K=1,N
      TEMP = VECT(K,I)
      VECT(K,I) = VECT(K,J)
  470 VECT(K,J) = TEMP
  480 CONTINUE
C
C  DEGENERATE VECTORS ARE NOW COMPLETE.
C
      GO TO 940
C
C  EIGENVECTORS OF TRIDIAGONAL MATRIX FOR NONDEGENERATE MATRICES.
C  INITIALIZE VECTOR ARRAY.
C
  807 CONTINUE
      DO 705 I=1,NROOT
      DO 15 J=1,N
   15 VECT(J,I) = 1.D0
  705 CONTINUE
      DO 700 I=1,NROOT
C
C  USE INVERSE ITERATION TO FIND VECTORS.
C
  701 AROOT = ROOT(I)
      ELIM1 = A(1) - AROOT
      ELIM2 = B(1,1)
      JUMP = 1
      DO 750 J=1,NM1
      JUMP = JUMP + J + 1
C
C  GET THE CORRECT PIVOT EQUATION FOR THIS STEP.
C
      IF (DABS(ELIM1).LE.DABS(B(J,1))) GO TO 760
C
C  FIRST (ELIM1) EQUATION IS THE PIVOT THIS TIME.  CASE 1.
C
      B(J,2) = ELIM1
      B(J,3) = ELIM2
      B(J,4) = 0.D0
      TEMP = B(J,1)/ELIM1
      ELIM1 = A(JUMP) - AROOT - TEMP*ELIM2
      ELIM2 = B(J+1,1)
      GO TO 755
C
C  SECOND EQUATION IS THE PIVOT THIS TIME.  CASE 2.
C
  760 B(J,2) = B(J,1)
      B(J,3) = A(JUMP) - AROOT
      B(J,4) = B(J+1,1)
      TEMP = 1.D0
      IF (DABS(B(J,1)).GT.THETA1) TEMP = ELIM1/B(J,1)
      ELIM1 = ELIM2 - TEMP*B(J,3)
      ELIM2 = -TEMP*B(J+1,1)
C
C  SAVE FACTOR FOR THE SECOND ITERATION.
C
  755 B(J,5) = TEMP
  750 CONTINUE
      B(N,2) = ELIM1
      B(N,3) = 0.D0
      B(N,4) = 0.D0
      B(NM1,4) = 0.D0
      ITER = 1
C
C  BACK SUBSTITUTE TO GET THIS VECTOR.
C
  790 L = N + 1
      DO 780 J=1,N
      L = L - 1
  786 CONTINUE
      ELIM1 = VECT(L,I)-VECT(L+1,I)*B(L,3)-VECT(L+2,I)*B(L,4)
C
C  IF OVERFLOW IS CONCEIVABLE, SCALE THE VECTOR DOWN. THIS APPROACH
C  IS USED TO AVOID MACHINE-DEPENDENT AND SYSTEM-DEPENDENT CALLS TO
C  OVERFLOW ROUTINES.
C
      IF (DABS(ELIM1).GT.DELBIG) GO TO 782
      TEMP = B(L,2)
      IF (DABS(B(L,2)).LT.DELTA) TEMP = DELTA
      VECT(L,I) = ELIM1/TEMP
      GO TO 780
  782 DO 784 K=1,N
  784 VECT(K,I) = VECT(K,I)/DELBIG
      GO TO 786
  780 CONTINUE
      GO TO (820,900), ITER
C
C  SECOND ITERATION.
C
  820 ITER = ITER + 1
  890 ELIM1 = VECT(1,I)
      DO 830 J=1,NM1
      IF (B(J,2).EQ.B(J,1)) GO TO 840
C
C  CASE ONE.
C
  850 VECT(J,I) = ELIM1
      ELIM1 = VECT(J+1,I) - ELIM1*B(J,5)
      GO TO 830
C
C  CASE TWO.
C
  840 VECT(J,I) = VECT(J+1,I)
      ELIM1 = ELIM1 - VECT(J+1,I)*TEMP
  830 CONTINUE
      VECT(N,I) = ELIM1
      GO TO 790
C
C  NORMALIZE THE VECTOR.
C
  900 ELIM1 = 0.D0
      DO 904 J=1,N
  904 ELIM1 = DMAX1(DABS(VECT(J,I)),ELIM1)
      TEMP = 0.D0
      DO 910 J=1,N
      ELIM2 = VECT(J,I)/ELIM1
  910 TEMP = TEMP + ELIM2**2
      TEMP = 1.D0/(DSQRT(TEMP)*ELIM1)
      DO 920 J=1,N
      VECT(J,I) = VECT(J,I)*TEMP
      IF (DABS(VECT(J,I)).LT.DEL1) VECT(J,I) = 0.D0
  920 CONTINUE
  700 CONTINUE
C
C  ROTATE THE CODIAGONAL VECTORS INTO VECTORS OF ORIGINAL ARRAY.
C  LOOP OVER ALL THE TRANSFORMATION VECTORS.
C
  940 IF (NM2.EQ.0) GO TO 1002
      JUMP = NSIZE - NP1
      IM = NM1
      DO 950 I=1,NM2
      LIMIT = IDINT(B(IM-1,6))
      J1 = JUMP
C
C  MOVE A TRANSFORMATION VECTOR OUT INTO BETTER INDEXING POSITION.
C
      DO 955 J=IM,LIMIT
      B(J,2) = A(J1)
  955 J1 = J1 + J
      IDIF = LIMIT - IM
C
C  MODIFY ALL REQUESTED VECTORS.
C
      DO 960 K=1,NROOT
C
C  FORM SCALAR PRODUCT OF TRANSFORMATION VECTOR WITH EIGENVECTOR.
C
      TMP = DOT(B(IM,2),VECT(IM,K))
      FACT = -TMP - TMP
      CALL VECSUM(VECT(IM,K),B(IM,2))
  960 CONTINUE
      JUMP = JUMP - IM
  950 IM = IM - 1
 1002 CONTINUE
C
C  RESTORE ROOTS TO THEIR PROPER SIZE AND ADD BACK TRACE.
C
      DO 95 I=1,N
   95 ROOT(I) = ROOT(I)*ANORM + TRACE
 1001 RETURN
      END
      SUBROUTINE EVQR(A,B,N,M,TOL)
C
C  SUBROUTINE FOR PERFORMING A QR TRANSFORM ON A REAL SYMMETRIC
C  TRIDIAGONAL MATRIX.
C
C  ON ENTERING, A CONTAINS THE N DIAGONAL ELEMENTS OF THE TRIDIAGONAL
C  MATRIX. B CONTAINS THE SQUARES OF THE N-1 OFF-DIAGONAL ELEMENTS.
C  ITERATION IS CONTINUED UNTIL THE SQUARES OF THE OFF-DIAGONAL
C  ELEMENTS ARE LESS THAN TOL. TYPICALLY LESS THAN TWO ITERATIONS PER
C  EIGENVALUE ARE REQUIRED. THUS THE UPPER LIMIT M TO THE NUMBER OF
C  ITERATIONS PER EIGENVALUE MAY BE SAFELY SET AT 20 OR SO.
C
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION A(1),B(1)
      NX = N
      NI = 1
      SH = 0.D0
C
C  K COUNTS THE NUMBER OF ITERATIONS PER EIGENVALUE.
C
      K = 0
      IF (NX-2) 50,60,85
C
C  EACH NEW ITERATION BEGINS HERE.
C
  100 K = K + 1
      IF (K.LT.M) GO TO 101
      WRITE (6,1000) K
 1000 FORMAT(35H NO CONVERGENCE OF QR ALGORITHM IN   ,I4,11H ITERATIONS)
      CALL EXIT
C
C  SOLVE THE TWO BY TWO IN THE LOWER RIGHT CORNER AND USE SMALLER ROOT
C  AS THE NEXT SHIFT.
C
  101 AT = A(NX) + A(NX-1)
      ST = AT*5.D-1
      DISC = AT**2 - 4.D0*(A(NX)*A(NX-1)-B(NX-1))
      IF (DISC.LE.0.D0) GO TO 15
      ST = ST - DSIGN(DSQRT(DISC),ST)*5.D-1
C
C  INCREASE THE TOTAL SHIFT BY THE TEMPORARY SHIFT.
C
   15 SH = SH + ST
C
C  THIS LOOP SUBTRACTS THE TEMPORARY SHIFT FROM THE DIAGONAL ELEMENTS.
C
      DO 20 I=1,NX
   20 A(I) = A(I) - ST
C
C  INITIALIZE.
C
      G = A(NI)
      PS = G**2
      RS = PS + B(NI)
      SX = B(NI)/RS
      CXS = 1.D0
      CX = PS/RS
      U = SX*(G+A(NI+1))
      A(NI) = G + U
      NTOP = NX - 2
C
C  THIS LOOP COMPLETES ONE ITERATION, THAT IS ONE QR TRANSFORM.
C
      DO 10 I=NI,NTOP
C
C  G IS THE GAMMA IN THE NOTATION OF WILKINSON.
C
      G = A(I+1) - U
      IF (CX.GT.TOL) GO TO 12
      PS = B(I)*CXS
      GO TO 16
   12 PS = G**2/CX
   16 RS = PS + B(I+1)
C
C  ROTATE AN OFF-DIAGONAL ELEMENT.
C
      B(I) = SX*RS
      SX = B(I+1)/RS
      CXS = CX
      CX = PS/RS
      U = SX*(G+A(I+2))
C
C  ROTATE A DIAGONAL ELEMENT.
C
      A(I+1) = G + U
   10 CONTINUE
C
C  COMPUTE THE LAST DIAGONAL ELEMENT.
C
      A(NX) = A(NX) - U
C
C  COMPUTE THE LAST OFF-DIAGONAL ELEMENT.
C
      IF (CX.GT.TOL) GO TO 112
      PS = B(NTOP+1)*CXS
      GO TO 116
  112 PS = ((A(NX))**2)/CX
  116 B(NTOP+1) = SX*PS
C
C  END OF ONE ITERATION.
C
   85 IT = NX
C
C  CHECK UPWARD THROUGH THE OFF-DIAGONAL ELEMENTS TO FIND THOSE LESS
C  THAN TOL. IF NO OFF-DIAGONAL ELEMENTS LESS THAN TOL ARE FOUND,
C  PERFORM ANOTHER ITERATION.
C
   30 IT = IT-1
      IF (DABS(B(IT)).LE.TOL) GO TO 40
      IF (IT-NI) 100,100,30
C
C  BRANCH ACCORDING TO WHETHER THE MATRIX ISOLATED BY THE SMALL
C  OFF-DIAGONAL ELEMENT IS OF DIMENSION ONE, TWO, OR MORE.
C
   40 IF (NX-IT-2) 50,60,70
C
C  EXTRACT THE EIGENVALUE OF A ONE BY ONE MATRIX BY ADDING BACK
C  THE SHIFT.
C
   50 A(NX) = A(NX) + SH
C
C  DECREASE THE SIZE OF THE PORTION OF THE MATRIX AFFECTED BY
C  LATER ITERATIONS.
C
      NX = NX-1
C
C  RESET THE ITERATION COUNTER.
C
      K = 1
      GO TO 80
C
C  EXTRACT THE EIGENVALUES FROM A TWO BY TWO MATRIX.
C
   60 AL = B(NX-1)
      AM = 5.D-1*(A(NX-1)-A(NX))
      AMS = AM**2
      SAM = DSIGN(1.D0,AM)
      AN = DSQRT(AL+AM**2)
      CX = (AN+DABS(AM))/(2.D0*AN)
      SX = B(NX-1)/(4.D0*AN**2*CX)
      TA = A(NX-1)
      TB = A(NX)
      TC = B(NX-1)
      I = NX
C
C  ROTATE THE DIAGONAL ELEMENTS AND THE OFF-DIAGONAL ELEMENTS.
C
      A(NX-1) = TA*CX+TB*SX+TC*SAM/AN+SH
      A(NX) = TA*SX+TB*CX-TC*SAM/AN+SH
      B(NX-1) = 4.D0*AMS*CX*SX-DABS(AM)*TC/AN+TC*(CX-SX)**2
C
C  RESET THE ITERATION COUNTER.
C
      K = 1
C
C  DECREASE THE SIZE OF THE PORTION OF THE MATRIX AFFECTED BY THE LATER
C  ITERATIONS.
C
      NX = NX-2
      GO TO 80
C
C  THE NEXT STATEMENT IS REACHED WHEN THE PORTION OF THE MATRIX
C  ISOLATED IS GREATER THAN TWO BY TWO.  IT CHANGES THE LOWER LIMIT
C  OF THE ITERATION SO THAT ONLY THIS PORTION WILL BE AFFECTED BY
C  SUBSEQUENT ROTATIONS UNTIL ALL ITS EIGENVALUES ARE FOUND.
C
   70 NI = IT + 1
C
C  TRANSFER TO BEGINNING OF ANOTHER ITERATION.
C
      GO TO 85
C
C  NEXT STATEMENT IS REACHED AFTER EITHER ONE OR TWO EIGENVALUES
C  HAVE JUST BEEN FOUND.  IT TRANSFERS IF ALL THE EIGENVALUES IN
C  THIS PORTION OF THE MATRIX HAVE BEEN FOUND.
C
   80 IF (NX.LT.NI) GO TO 90
C
C  BRANCH ACCORDING TO WHETHER ONE, TWO, OR MORE EIGENVALUES REMAIN
C  TO BE FOUND.
C
   95 IF (NX-NI-1) 50,60,85
C
C  THE NEXT STATEMENT IS REACHED WHEN ALL EIGENVALUES IN THIS PART
C  OF THE MATRIX HAVE BEEN FOUND. IT RETURNS IF THIS IS THE LAST
C  PART OF THE MATRIX.
C
   90 IF (NI.EQ.1) RETURN
C
C  ENLARGE THE PORTION OF THE MATRIX BEING TREATED TO INCLUDE THE
C  BEGINNING OF THE MATRIX.
C
      NI = 1
      GO TO 95
      END
      SUBROUTINE QRTN (A,B,V,EIG,N,M,TOL,NJX)
C
C  SUBROUTINE FOR PERFORMING A QR TRANSFORM ON A REAL SYMMETRIC
C  TRIDIAGONAL MATRIX.
C
C  N IS THE DIMENSION OF THE MATRIX. A CONTAINS THE N DIAGONAL
C  ELEMENTS OF THE TRIDIAGONAL MATRIX. B CONTAINS THE N-1 OFF-
C  DIAGONAL ELEMENTS. M IS THE MAXIMUM NUMBER OF ITERATIONS ( SAY
C  20 ). NJX IS THE PHYSICAL ROW DIMENSION OF THE EIGENVECTOR
C  MATRIX V.
C
C  THE EIGENVALUES ARE ASSUMED KNOWN AND PLACED IN THE FIRST N
C  ELEMENTS OF EIG.
C
C  N VECTORS V ( EACH OF LENGTH N ) ARE TRANSFORMED INTO THE
C  BASIS IN WHICH THE MATRIX IS DIAGONAL.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION A(1),B(1),V(1),EIG(1)
      NX = N
      NNM1 = NJX*(NX-1)
      NI = 1
C
C  SET INITIAL TOTAL SHIFT.
C
      SH = 0
      IF (NX-2) 50,60,1
C
C  K COUNTS THE NUMBER OF ITERATIONS PER EIGENVALUE.
C
    1 K=0
C
C  SET INITIAL TEMPORARY SHIFT.
C
   98 ST = EIG(NX)-SH
C
C  CHECK FOR SMALL OFF-DIAGONAL ELEMENTS.
C
      IT = NX
   99 IT = IT-1
      IF (DABS(B(IT)).LE.TOL) GO TO 40
      IF (IT.GT.NI) GO TO 99
C
C  NO SMALL OFF-DIAGONAL ELEMENTS FOUND.  ITERATE.  EACH NEW
C  ITERATION BEGINS HERE.
C
  100 K = K + 1
      IF (K.LT.M) GO TO 11
      WRITE (6,1000) K
 1000 FORMAT(35H NO CONVERGENCE OF QR ALGORITHM IN   ,I4,11H ITERATIONS)
      CALL EXIT
   11 IF (K.EQ.1) GO TO 15
C
C  SOLVE THE TWO BY TWO IN THE LOWER RIGHT CORNER AND USE SMALLER ROOT
C  AS THE NEXT SHIFT.
C
   12 AT = A(NX) + A(NX-1)
      ST = AT*5.D-1
      DISC = AT**2-4.D0*(A(NX)*A(NX-1)-B(NX-1)**2)
      IF (DISC.LE.0.D0) GO TO 15
      ST = ST-DSIGN(DSQRT(DISC),ST)*5.D-1
C
C  INCREASE THE TOTAL SHIFT BY THE TEMPORARY SHIFT.
C
   15 SH = SH + ST
C
C  THIS LOOP SUBTRACTS THE TEMPORARY SHIFT FROM THE DIAGONAL ELEMENTS.
C
      DO 20 I=1,NX
   20 A(I) = A(I) - ST
      R = DSQRT(A(NI)**2+B(NI)**2)
      S = B(NI)/R
      CS = S
      C = A(NI)/R
      U = (S**2)*(A(NI)+A(NI+1))
      A(NI) = A(NI) + U
      CALL ROTATE(V(NI),C,S,NJX,NNM1)
      NTOP = NX - 2
C
C  THIS LOOP COMPLETES ONE ITERATION, THAT IS ONE QR TRANSFORM.
C
      DO 10 I=NI,NTOP
C
C  G IS THE GAMMA AND Q IS THE P IN THE NOTATION OF WILKINSON.
C
      G = A(I+1) - U
      Q = C*A(I+1) - CS*B(I)
      R = DSQRT(Q**2+B(I+1)**2)
C
C  ROTATE AN OFF-DIAGONAL ELEMENT.
C
      B(I) = S*R
C
C  FIND THE NEW SINE AND COSINE FOR THE JACOBI ROTATION. THEN
C  COMPUTE A NEW U.
C
      S = B(I+1)/R
      CS = C*S
      C = Q/R
      U = (S**2)*(G+A(I+2))
C
C  ROTATE A DIAGONAL ELEMENT.
C
      A(I+1) = G + U
C
C  ROTATE THE VECTORS.
C
      CALL ROTATE (V(I+1),C,S,NJX,NNM1)
   10 CONTINUE
C
C  COMPUTE THE LAST OFF DIAGONAL ELEMENT.
C
      B(NTOP+1) = S*(C*A(NX)-CS*B(NTOP+1))
C
C  COMPUTE THE LAST DIAGONAL ELEMENT.
C
      A(NX) = A(NX) - U
C
C  END OF ONE ITERATION.
C
   85 IT = NX
C
C  CHECK UPWARD THROUGH THE OFF DIAGONAL ELEMENTS TO FIND THOSE LESS
C  THAN TOL. IF NO OFF-DIAGONAL ELEMENTS LESS THAN TOL ARE FOUND,
C  PERFORM ANOTHER ITERATION.
C
   30 IT = IT - 1
      IF (DABS(B(IT)).LE.TOL) GO TO 40
      IF (IT-NI) 100,100,30
C
C  BRANCH ACCORDING TO WHETHER THE MATRIX ISOLATED BY THE SMALL
C  OFF-DIAGONAL ELEMENT IS OF DIMENSION ONE, TWO, OR MORE.
C
   40 IF (NX-IT-2) 50,60,70
C
C  EXTRACT THE EIGENVALUE OF A ONE BY ONE MATRIX BY ADDING BACK
C  THE SHIFT.
C
   50 A(NX) = A(NX) + SH
C
C  DECREASE THE SIZE OF THE PORTION OF THE MATRIX AFFECTED BY
C  LATER ITERATIONS.
C
      NX = NX - 1
C
C  RESET THE ITERATION COUNTER.
C
      K = 0
      GO TO 80
C
C  EXTRACT THE EIGENVALUES FROM A TWO BY TWO MATRIX AND PERFORM THE
C  CORRESPONDING ROTATIONS ON THE VECTORS.
C
   60 AL = -B(NX-1)
      AM = 5.D-1*(A(NX-1)-A(NX))
      AN = DSQRT(AL**2+AM**2)
      C = DSQRT((AN+DABS(AM))/(2.D0*AN))
      S = DSIGN(5.D-1,AM)*AL/(AN*C)
      TA = A(NX-1)
      TB = A(NX)
      TC = B(NX-1)
      CX = C**2
      SX = S**2
      CS = C*S
C
C  ROTATE THE DIAGONAL ELEMENTS, THE OFF-DIAGONAL ELEMENTS, AND
C  THE VECTORS.
C
      A(NX-1) = TA*CX+TB*SX-2.D0*TC*CS+SH
      A(NX) = TA*SX+TB*CX+2.D0*TC*CS+SH
      B(NX-1) = 2.D0*AM*CS+TC*(CX-SX)
      I = NX-1
      S = -S
      CALL ROTATE (V(I),C,S,NJX,NNM1)
C
C  RESET THE ITERATION COUNTER.
C
      K = 0
C
C  DECREASE THE SIZE OF THE PORTION OF THE MATRIX AFFECTED BY THE
C  LATER ITERATIONS.
C
      NX = NX-2
      GO TO 80
C
C  THE NEXT STATEMENT IS REACHED WHEN THE PORTION OF THE MATRIX
C  ISOLATED IS GREATER THAN TWO BY TWO.  IT CHANGES THE LOWER LIMIT
C  OF THE ITERATION SO THAT ONLY THIS PORTION WILL BE AFFECTED BY
C  SUBSEQUENT ROTATIONS UNTIL ALL ITS EIGENVALUES ARE FOUND.
C
   70 NI = IT + 1
C
C  TRANSFER TO BEGINNING OF ANOTHER ITERATION.
C
      GO TO 100
C
C  NEXT STATEMENT IS REACHED AFTER EITHER ONE OR TWO EIGENVALUES
C  HAVE JUST BEEN FOUND.  IT TRANSFERS IF ALL THE EIGENVALUES IN
C  THIS PORTION OF THE MATRIX HAVE BEEN FOUND.
C
   80 IF (NX.LT.NI) GO TO 90
C
C  BRANCH ACCORDING TO WHETHER ONE, TWO, OR MORE EIGENVALUES REMAIN
C  TO BE FOUND.
C
   95 IF (NX-NI-1) 50,60,98
C
C  THE NEXT STATEMENT IS REACHED WHEN ALL EIGENVALUES IN THIS PART
C  OF THE MATRIX HAVE BEEN FOUND. IT RETURNS IF THIS IS THE LAST
C  PART OF THE MATRIX.
C
   90 IF (NI.EQ.1) RETURN
C
C  ENLARGE THE PORTION OF THE MATRIX BEING TREATED TO INCLUDE THE
C  BEGINNING OF THE MATRIX.
C
      NI = 1
      GO TO 95
      END
      DOUBLE PRECISION FUNCTION DOT(A,B)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION A(1),B(1)
      COMMON /VECTOR/ FACTOR,LIMIT
C
C    FUNCTION FOR USE IN GIVENS DIAGNOLIZATION PACKAGE.
C
      ITOP=LIMIT+1
      DOT=0.D0
      DO 10 I=1,ITOP
 10   DOT=DOT+A(I)*B(I)
      RETURN
      END
      DOUBLE PRECISION FUNCTION DSUM(B,A,IP1,LIMIT)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION B(1),A(1)
C
C    FUNCTION FOR USE IN GIVENS DIAGNOLIZATION PACKAGE.
C
      JJ=1
      DSUM=0.D0
      DO 180 II=IP1,LIMIT
      DSUM=DSUM+B(II+1)*A(JJ)
 180  JJ=JJ+II
      RETURN
      END
      SUBROUTINE VECSUM(A,B)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION A(1),B(1)
      COMMON /VECTOR/ FACTOR,LIMIT
C
C    FUNCTION FOR USE IN GIVENS DIAGNOLIZATION PACKAGE.
C
      ITOP=LIMIT+1
      DO 10 I=1,ITOP
 10   A(I)=A(I)+FACTOR*B(I)
      RETURN
      END
      SUBROUTINE ROTATE(V,C,S,NJX,JTOP)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION V(1)
C
C    FUNCTION FOR USE IN GIVENS DIAGNOLIZATION PACKAGE.
C
      JLIM=JTOP+1
      DO 10 J=1,JLIM,NJX
      TA=V(J)
      TB=V(J+1)
      V(J)=TA*C+TB*S
 10   V(J+1)=TB*C-TA*S
      RETURN
      END
